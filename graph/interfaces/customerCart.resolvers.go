package interfaces

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	"github.com/shyams2012/buy-best/graph/generated"
	"github.com/shyams2012/buy-best/graph/model"
)

// AddCustomerCart is the resolver for the addCustomerCart field.
func (r *mutationResolver) AddCustomerCart(ctx context.Context, productIds []*string) (*model.CustomerCart, error) {
	loggedUser, _ := r.Query().GetMe(ctx)
	//var inventory []*model.Inventory

	var customerCart model.CustomerCart
	var customerAmount model.CustomerAmount
	customerCart.CustomerID = loggedUser.ID
	customerCart.CreatedAt = time.Now()
	customerCart.ModifiedAt = time.Now()
	var price float64
	var sum float64
	var quantities []int
	// if tx := r.DB().Find(&inventory); tx.Error != nil {
	// 	log.Print(tx.Error)
	// 	return nil, tx.Error
	// }
	// type Result struct {
	// 	Quantity int
	// }

	// var result []Result

	for _, productId := range productIds {

		if tx := r.DB().Table("inventories").Select("quantity").Where("product_id = ?", productId).Scan(&quantities); tx.Error != nil {
			log.Print(tx.Error)
			return nil, fmt.Errorf("quantity not Found, id=%s", *productId)
		}

		for _, quantity := range quantities {
			if quantity != 0 {
				fmt.Print("found", quantity)

				customerCart.ID = uuid.NewString()
				customerCart.ProductID = *productId
				if tx := r.DB().Table("products").Select("price").Where("id = ?", productId).Scan(&price); tx.Error != nil {
					log.Print(tx.Error)
					return nil, fmt.Errorf("price not Found, id=%s", *productId)
				}

				customerCart.Amount = price
				sum += price

				if tx := r.DB().Create(&customerCart); tx.Error != nil {
					log.Print(tx.Error)
					return nil, fmt.Errorf("error saving customerCart")

				}
			} else {
				fmt.Print("out of stock")
			}
		}
	}

	customerAmount.ID = uuid.NewString()
	customerAmount.CustomerID = loggedUser.ID
	customerAmount.Amount = sum
	customerAmount.CreatedAt = time.Now()
	customerAmount.ModifiedAt = time.Now()
	var isCustomerExist string

	if tx := r.DB().Model(&model.CustomerAmount{}).Select("customer_id").Where("customer_id = ?", customerAmount.CustomerID).Scan(&isCustomerExist); tx.Error != nil {
		log.Print(tx.Error)
		return nil, fmt.Errorf("customer_id not Found, id=%s", customerAmount.CustomerID)
	}

	if len(isCustomerExist) > 0 {
		var amount float64

		if tx := r.DB().Model(&model.CustomerAmount{}).Select("amount").Where("customer_id = ?", customerAmount.CustomerID).Scan(&amount); tx.Error != nil {
			log.Print(tx.Error)
			return nil, fmt.Errorf("customer_id, amount  not Found , id=%s", customerAmount.CustomerID)
		}

		if tx := r.DB().Model(&model.CustomerAmount{}).Where("customer_id = ?", isCustomerExist).Updates(model.CustomerAmount{Amount: amount + sum}); tx.Error != nil {
			log.Print(tx.Error)
			return nil, fmt.Errorf("err while updating customerAmount, id=%s", isCustomerExist)
		}
	} else {
		if tx := r.DB().Create(&customerAmount); tx.Error != nil {
			log.Print(tx.Error)
			return nil, fmt.Errorf("err while creating customerAmount, id")
		}
	}
	return &customerCart, nil
}

// DeleteCustomerCart is the resolver for the deleteCustomerCart field.
func (r *mutationResolver) DeleteCustomerCart(ctx context.Context, productIds []*string) (bool, error) {
	var cart model.CustomerCart
	var price float64
	var amount float64
	loggedUser, _ := r.Query().GetMe(ctx)

	for _, productId := range productIds {

		if tx := r.DB().Model(&model.Product{}).Select("price").Where("id = ?", productId).Scan(&price); tx.Error != nil {
			log.Print(tx.Error)
			return false, fmt.Errorf("err while getting price")
		}

		if tx := r.DB().Model(&model.CustomerAmount{}).Select("amount").Where("customer_id = ?", loggedUser.ID).Scan(&amount); tx.Error != nil {
			log.Print(tx.Error)
			return false, fmt.Errorf("err while getting amount, id")
		}

		amount -= price

		if tx := r.DB().Model(&model.CustomerAmount{}).Where("customer_id = ?", loggedUser.ID).Updates(model.CustomerAmount{Amount: amount}); tx.Error != nil {
			log.Print(tx.Error)
			return false, fmt.Errorf("err while updating customerAmount")
		}

		if tx := r.DB().Where("product_id = ? AND customer_id = ?", *productId, loggedUser.ID).Delete(&cart); tx.Error != nil {
			log.Print(tx.Error)
			return false, fmt.Errorf("error deleting %s", productId)
		}
	}
	return true, nil
}

// GetCustomerCarts is the resolver for the getCustomerCarts field.
func (r *queryResolver) GetCustomerCarts(ctx context.Context) ([]*model.CustomerCart, error) {
	var customerCarts []*model.CustomerCart
	loggedUser, _ := r.Query().GetMe(ctx)

	if tx := r.DB().Table("customer_amounts").Select("amount").Where("customer_id = ?", loggedUser.ID).Scan(&customerCarts); tx.Error != nil {
		log.Print(tx.Error)
		return nil, tx.Error
	}
	fmt.Println(customerCarts)
	return customerCarts, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
